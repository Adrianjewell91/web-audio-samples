<!--
Copyright 2017 Google Inc.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
-->
<!DOCTYPE html>
  <head>
    <script src="test/testharness.js"></script>
    <script src="test/testharnessreport.js"></script>
    <script src="test/audit-util.js"></script>
    <script src="test/audit.js"></script>
    <script src="src/noisegate-script-processor.js"></script>
    <script id="noisegate-test-code">
      // Sample rate is a power of two to avoid interpolation from delay node.
      // It is held artificially low for easy inspection of audio buffers. With
      // a higher sample rate, there may be trivial failures to certain tests.
      // In the envelope-and-threshold test, a couple more of the first samples
      // may be altered in the noise gate output. In the attack-and-release
      // test, there may be one amplitude which, during the attack/release
      // phase, has a greater/smaller value than the previous amplitude.
      const sampleRate = 4096;
      const testDurationSec = 1;
      const testFrames = testDurationSec * sampleRate;
      const bufferSize = 512;
      const scriptProcessorLatency = bufferSize * 2;

      // The threshold for envelope and attack and release tests is some number
      // between the aboveThresholdGain and belowThresholdGain. If the threshold
      // is close to the belowThresholdGain, then the gate may flutter between
      // opened and closed, causing the test to fail.
      const linearThreshold = 0.2;
      const threshold = toDecibel_(linearThreshold);
      const aboveThresholdGain = linearThreshold * 1.25;
      const belowThresholdGain = linearThreshold * 0.75;

      let audit = Audit.createTaskRunner();
      
      // Verify that the noise gate gradually mutes the signal according to the
      // attack parameter, and that it gradually returns the signal to its
      // original value according to the release parameter. Precise timing is
      // not confirmed in this test and is separately investigated in the gain
      // computer tests.
      audit.define('attack-and-release', (task, should) => {
        let context = new OfflineAudioContext(2, testFrames, sampleRate);

        // The desired number of attacking and releasing steps (the number of
        // samples it will take from when the threshold is hit to when it is
        // fully open or fully closed) is set to be an arbitrary number greater
        // than the bufferSize to ensure that the test success depends on proper
        // noise gate memory between blocks. If this value is set to be larger,
        // then tests may fail since the closed phase at the end is too short.
        const attackAndReleaseSteps = bufferSize + 128;
        const attack = toTime_(attackAndReleaseSteps, sampleRate);
        const release = attack;
        let firstDecreasingIndex = attackAndReleaseSteps;
        const startOfDrop = toTime_(firstDecreasingIndex, sampleRate);
        
        // The amount of time it takes for gain to move from a value above the
        // threshold to a value beneath the threshold is set to be larger than
        // the intended amount of attack and release steps so that a linear
        // decrease can be verified for the attacking phase.
        const gainChangeTime = toTime_(attackAndReleaseSteps, sampleRate);
        const endOfDrop = startOfDrop + gainChangeTime;
        
        // The signal will rise some number of indexes later than
        // startOfDrop to allow time to inspect the fully closed gate.
        const startOfRise = endOfDrop + toTime_(bufferSize, sampleRate);
        const endOfRise = startOfRise + gainChangeTime;
        const gain = new GainNode(context, {gain: aboveThresholdGain});
        gain.gain.linearRampToValueAtTime(aboveThresholdGain, startOfDrop);
        gain.gain.linearRampToValueAtTime(belowThresholdGain, endOfDrop);
        gain.gain.linearRampToValueAtTime(belowThresholdGain, startOfRise);
        gain.gain.linearRampToValueAtTime(aboveThresholdGain, endOfRise);

        let noisegate = new NoiseGate(
            context, {bufferSize, attack, release, threshold});
        let delay = new DelayNode(
            context, {delayTime : toTime_(scriptProcessorLatency, sampleRate)});
        let oscillator = new OscillatorNode(context);
        let merger = new ChannelMergerNode(context, {numberOfInputs: 2});

        oscillator.connect(gain).connect(noisegate.input);
        gain.connect(delay);
        noisegate.output.connect(merger, 0, 0);
        delay.connect(merger, 0, 1);
        merger.connect(context.destination);

        // Drop the bass!
        oscillator.start();

        context.startRendering().then((buffer) => {
          const noiseGateOutput = buffer.getChannelData(0);
          const originalOutput = buffer.getChannelData(1);

          // Verify 6 phases of the output:
          // 1. Latency Phase: all zeros until scriptProcessorLatency
          // 2. Open Phase 1: unaffected until firstDecreasingIndex
          // 3. Attacking Phase: decreasing over time until 0
          // 4. Closed Phase: all zeros until firstReleaseIndex
          // 5. Releasing Phase: increasing until identical to original output
          // 6. Open phase 2: unaffected until the last sample
          
          // 1. Latency phase
          let latencyPhase 
              = noiseGateOutput.slice(0, scriptProcessorLatency);
          should(latencyPhase, 'The script processor latency phase')
              .beConstantValueOf(0);

          // 2. Open Phase 1: the signal is unaltered.
          firstDecreasingIndex += scriptProcessorLatency;
          let openPhase1 = noiseGateOutput.slice(scriptProcessorLatency,
                                                 firstDecreasingIndex);
          let openPhase1Reference = originalOutput.slice(scriptProcessorLatency,
                                                         firstDecreasingIndex);
          // The first k samples run through the noise gate will be somewhat
          // altered. This effect occurs since the envelope does not
          // immediately respond to the level of the signal and it will be
          // beneath the threshold for the first k samples which causes the
          // noise gate to enter an attacking state and slightly diminish the
          // amplitude of the oscillator.
          const numberOfAlteredSamples =
              getFirstIndexBeforeRemainingSamplesMatch_(openPhase1,
                                                        openPhase1Reference);

          // With current settings, delayInSeconds is 0.004638671875s.
          const delayInSeconds = toTime_(numberOfAlteredSamples, sampleRate);
          should(delayInSeconds,
                 'The envelope delay for the very first samples')
              .beCloseTo(0.0045, {threshold: 0.05});
              
          openPhase1 =
              openPhase1.slice(numberOfAlteredSamples, openPhase1.length);
          openPhase1Reference = openPhase1Reference.slice(
              numberOfAlteredSamples, openPhase1Reference.length);
          should(openPhase1, 'The open phase of noise gate output')
              .beEqualToArray(
                  openPhase1Reference,
                  'the original samples generated by the oscillator');

          // 3. Attacking phase: the signal should decreases until 0.
          const firstReleaseIndex =
              toIndex_(startOfRise, sampleRate) + scriptProcessorLatency;
          let decreasingAndClosedPhase =
              noiseGateOutput.slice(firstDecreasingIndex, firstReleaseIndex);
          let changeLength =
              getFirstIndexBeforeRemainderIs_(decreasingAndClosedPhase, 0);
          let gainReducingPhase =
              decreasingAndClosedPhase.slice(0, changeLength);
          let closedPhase =
              decreasingAndClosedPhase.slice(changeLength, firstReleaseIndex);

          should(changeLength, 'The number of steps when the signal reduces')
              .beGreaterThanOrEqualTo(
                  attackAndReleaseSteps,
                  'the number of programmed attack and release steps.');

          // The gain reduction phase is represented as k averaged amplitudes
          // and should decrease over time. K is set as ten as an arbitrary
          // value large enough to suggest a linear decrease over time. Some
          // tests may fail if k is set any higher.
          let amplitudes = getAveragedAmplitudes_(gainReducingPhase, 10);
          let lastAmplitude = amplitudes[0];
          for (let i = 1; i < amplitudes.length; i++) {
            should(amplitudes[i], 'The attacking amplitude at iteration ' + i)
                .beLessThan(amplitudes[i - 1],
                            'the attacking amplitude at iteration ' + (i - 1));
          }

          // 4. Closed Phase: the signal must remain at 0 for a non-trivial
          // period of time.
          should(closedPhase, 'The closed phase').beConstantValueOf(0);
          should(closedPhase.length, 'The closed phase')
              .beGreaterThanOrEqualTo(100);

          // 5. Releasing Phase: the noisegate signal increases until it matches
          // the original signal.
          let fromClosedToEndPhase =
              noiseGateOutput.slice(firstReleaseIndex, noiseGateOutput.length);
          let fromClosedToEndPhaseReference =
              originalOutput.slice(firstReleaseIndex, noiseGateOutput.length);
          let openIndex = getFirstIndexBeforeRemainingSamplesMatch_(
              fromClosedToEndPhase, fromClosedToEndPhaseReference);
          let gainIncreasingPhase = fromClosedToEndPhase.slice(0, openIndex);
          let openPhase2 =
              fromClosedToEndPhase.slice(openIndex, firstReleaseIndex);
          let openPhase2Reference =
              fromClosedToEndPhaseReference.slice(openIndex, firstReleaseIndex);

          should(gainIncreasingPhase.length,
                 'The number of steps when the signal is increasing')
              .beGreaterThanOrEqualTo(
                  attackAndReleaseSteps,
                  'the number of programmed attack and release steps.');

          amplitudes = getAveragedAmplitudes_(gainIncreasingPhase, 10);
          lastAmplitude = amplitudes[0];
          for (let i = 1; i < amplitudes.length; i++) {
            should(amplitudes[i], 'The attacking amplitude at iteration ' + i)
                .beGreaterThan(
                    amplitudes[i - 1],
                    'the attacking amplitude at iteration ' + (i - 1));
          }

          // 6. Open Phase 2: The gate eventually re-opens.
          should(openPhase2.length, 'The second open phase')
              .beGreaterThanOrEqualTo(100);
          should(openPhase2, 'The second open phase of noise gate output')
              .beEqualToArray(
                  openPhase2Reference,
                  'the original samples generated by the oscillator');

          }).then(() => task.done());
      })
      
      // Verify that the noise gate computes an envelope for an audio signal
      // that is on the same scale as web audio's gain node. If the gain of a
      // signal is set to be beneath the threshold, then the signal should be
      // muted. The gain of an oscillator is gradually decreased to some
      // threshold T at timeToThreshold, and the output of the noise gate
      // should be 0 after timeToThreshold and unaltered before timeToThreshold
      // within an acceptable margin of error. The attack and release test
      // also hinges on a properly functioning threshold and envelope. But
      // since this test doesn't use attack and release, it allows for the
      // envelope delay to be directly quantified, and the bandwidth of the
      // envelope detection exponential smoothing filter to be experimentally
      // adjusted to minimize envelope delay while avoiding the gate fluttering
      // between open and closed.
      audit.define('envelope-and-threshold', (task, should) => {
        let context = new OfflineAudioContext(2, testFrames, sampleRate);
        // TimeToThreshold should be between 0 and 1.
        const timeToThreshold = 0.25;

        // Attack and release are both 0.
        let noisegate = new NoiseGate(context, {bufferSize, threshold});
        let gain = new GainNode(context, {gain : 1});
        let merger = new ChannelMergerNode(context, {numberOfInputs : 2});
        // The delay node offsets the script processor latency.
        let delay = new DelayNode(
            context, {delayTime : toTime_(scriptProcessorLatency, sampleRate)});
        let osc = new OscillatorNode(context);

        osc.connect(gain).connect(noisegate.input);
        gain.connect(delay);
        noisegate.output.connect(merger, 0, 0);
        delay.connect(merger, 0, 1);
        merger.connect(context.destination);

        // Gain node should be stable until ~1 sample before the threshold, and
        // then it should drop to a value clearly beneath it.
        gain.gain.linearRampToValueAtTime(
            1, timeToThreshold - (1 / context.sampleRate));
        gain.gain.linearRampToValueAtTime(belowThresholdGain, timeToThreshold);

        // Drop the bass!
        osc.start();

        context.startRendering().then((buffer) => {
          let noiseGateOutput = buffer.getChannelData(0);
          let originalOutput = buffer.getChannelData(1);
          const closedIndex =
              toIndex_(timeToThreshold, sampleRate) + scriptProcessorLatency;

          // The output is divided into a latency phase, an unaltered phase, and
          // a closed phase.
          let latencyPhase = noiseGateOutput.slice(0, scriptProcessorLatency);
          let unalteredPhase =
              noiseGateOutput.slice(scriptProcessorLatency, closedIndex);
          let unalteredPhaseReference =
              originalOutput.slice(scriptProcessorLatency, closedIndex);

          // Based on knowledge of when the signal goes beneath the threshold,
          // it is possible to predict when the signal should be muted. However,
          // this calculation is imperfect since the envelope detection
          // algorithm has a delay.
          let ideallyClosedPhase =
              noiseGateOutput.slice(closedIndex, buffer.length);

          // The difference between when the gate is expected to be closed and
          // is closed) is measured at 0.009033203125s. If settings change, then
          // closeDelay can be inspected and the assertions can compare to this
          // benchmark instead. The delay occurs due to envelope lag and
          // changes based on alpha. Slight delay may be problematic if the
          // noise gate is intended to immediately mute sound
          // upon hitting a threshold and less problematic if a smooth
          // transition to silence is desired.
          let closeDelay =
              getFirstIndexBeforeRemainderIs_(ideallyClosedPhase, 0);
          should(
              toTime_(closeDelay, sampleRate),
              'The delay between when the envelope is expected to be closed and'
              + ' when it is closed')
              .beCloseTo(0.009, {threshold: 0.05});
          let closedPhase = ideallyClosedPhase.slice(closeDelay, buffer.length);

          should(latencyPhase, 'The latency phase of noise gate output')
              .beConstantValueOf(0);
          should(unalteredPhase, 'The noise gate values prior to the threshold')
              .beEqualToArray(unalteredPhaseReference,
                              'those values in the unaltered oscillator');
          should(closedPhase, 'The closed phase of the noise gate output')
              .beConstantValueOf(0);
        }).then(() => task.done());
      });

      // When processing two channels, the noise gate should compute only one
      // envelope from the average of those two
      // channels but apply gain computation separately for both channels.
      audit.define('multi-channel', (task, should) => {
        const numberOfChannels = 2;
        // Threshold should be 0.5 to allow the closing index to be predicted.
        // If this value changes, then expectedCutoffIndex also needs to change.
        const threshold = toDecibel_(0.5);
        let context =
            new OfflineAudioContext(numberOfChannels, testFrames, sampleRate);
        let oscillator = new OscillatorNode(context);
        let oscillator2 = new OscillatorNode(context);
        let gain = new GainNode(context, {gain: 1});
        let noisegate = new NoiseGate(context,
            {threshold, numberOfChannels, bufferSize});
        let merger = new ChannelMergerNode(context);
        
        // One oscillator is connected to a gain node which makes it
        // less than the threshold half way through buffer.
        oscillator.connect(gain);
        gain.connect(merger, 0, 0);
        oscillator2.connect(merger, 0, 1);
        merger.connect(noisegate.input);
        noisegate.output.connect(context.destination);
        gain.gain.linearRampToValueAtTime(0, 1);
        
        // Drop the basses!
        oscillator.start();
        oscillator2.start();

        context.startRendering().then((buffer) => {
            let firstChannel = buffer.getChannelData(0);
            let secondChannel = buffer.getChannelData(1);
            
            // If the gain of one channel decreases linearly to 0 over the
            // course of one second of data but the other channel has a steady
            // gain at one, then the noise gate (basing decisions on an average
            // of the two channels) should cut out the signal approximately
            // 3/4 of the way through the buffer.
            const expectedCutoffIndex =
                0.75 * sampleRate;
            const cutoffIndex1 =
                getFirstIndexBeforeRemainderIs_(firstChannel, 0);
            const cutoffIndex2 =
                getFirstIndexBeforeRemainderIs_(secondChannel, 0);

            should(cutoffIndex1, 'The noise-gate cutoff of the first channel')
                .beEqualTo(cutoffIndex2,
                           'the noise-gate cutoff of the second channel');

            // Delay is 0.020263671875s and is set as the difference
            // between when the gate was expected to close and when it closed.
            const delay = cutoffIndex1 - expectedCutoffIndex;
            should(
                toTime_(delay, sampleRate),
                'The difference between when the gate was expected to ' +
                'close and when it closed')
                .beCloseTo(0.02, {threshold: 0.05});
        }).then(() => task.done());
      });

      // Verify that the gain computer opens and closes gate (as witnessed
      // through changes in its weights) according to attack and release
      // settings.
      audit.define('gain-computer', (task, should) => {
        // All envelope values below threshold will receive
        // a zero weight and all values above will receive a weight of one
        // when attack and release are both 0.
        let context = new OfflineAudioContext(1, testFrames, sampleRate);
        // envelope[i] = i. Length needs to be an even number.
        const length = 100;
        let envelope = Array.apply(null, {length}).map((data, index) => index);
        const transitionIndex = length / 2;
        const threshold = toDecibel_(length / 2);
        let noisegate = new NoiseGate(context, {threshold});
        let weights = noisegate.computeGain_(envelope);
        let closedWeights = weights.slice(0, transitionIndex);
        let openWeights = weights.slice(transitionIndex, length);
        
        should(closedWeights, 'Weight array before threshold')
            .beConstantValueOf(0);
        should(openWeights, 'Weight array after the threshold')
            .beConstantValueOf(1);
        
        // Verify that the gain computer generates a sequence of increasing or
        // decreasing weights between 0 and 1 at threshold transitions.
        // TransitionSteps must be less than half the envelope length so that
        // both attack and release fit in the evaluation.
        const transitionSteps = 10;
        attack = toTime_(transitionSteps, sampleRate);
        release = attack;
        noisegate = new NoiseGate(context, {attack, release, threshold});
        weights = noisegate.computeGain_(envelope);

        let attackWeights = weights.slice(0, transitionSteps);
        closedWeights = weights.slice(transitionSteps, transitionIndex);
        let releaseWeights =
            weights.slice(transitionIndex, transitionIndex + transitionSteps);
        openWeights =
            weights.slice(transitionIndex + transitionSteps, length);
        let expectedAttackWeights = new Float32Array(transitionSteps);
        let expectedReleaseWeights = new Float32Array(transitionSteps);
        
        // Expected weights should align with noise gates weights. Attack
        // weights increase and release weights decrease.
        for (let j = 0; j < transitionSteps; j++) {
          // The first attack weight is 1 - (1 / transitionSteps).
          expectedAttackWeights[j] = 1 - ((j + 1) / transitionSteps);
          // Similarly, the first release weight is 1 / transitionSteps.
          expectedReleaseWeights[j] =  (j + 1) / transitionSteps;
        }

        // Allow for a small error (set experimentally) since the exact change 
        // in weight is computed differently here and in noisegate.computeGain.
        const errorThreshold = 1e-6;
        should(attackWeights, 'Attacking weights')
            .beCloseToArray(expectedAttackWeights, {absoluteThreshold: 1e-6});
        should(releaseWeights, 'Releasing weights')
            .beCloseToArray(expectedReleaseWeights, {absoluteThreshold: 1e-6});
        should(closedWeights, 'Weight array before threshold')
            .beConstantValueOf(0);
        should(openWeights, 'Weight array after the threshold')
            .beConstantValueOf(1);
        task.done();
      });

    audit.run();
    
    // End of test cases. Testing utility functions below!

    function getAveragedAmplitudes_(signal, numberOfAmplitudes) {
      // GoingUp is true if current value is greater than last value.
      let amplitudes = new Array();
      let goingUp = signal[1] > signal[0] ? true : false;
      
      // Peak is where amplitude is recorded.
      let peak = signal[0];
      for (let i = 2; i < signal.length; i++) {
        if (signal[i] <  signal[i-1]) {
          if (goingUp) {
            amplitudes.push(Math.abs(signal[i] - peak));
            peak = signal[i];
            goingUp = false;
          }
        } else {
          if (!goingUp) {
            amplitudes.push(Math.abs(signal[i] - peak));
            peak = signal[i];
            goingUp = true;
          }
        }
      }

      if (amplitudes.length < numberOfAmplitudes)
        throw 'Cannot request ' + numberOfAmplitudes +
            ' since there were only ' + amplitudes.length +
            ' distinct amplitudes in the signal.';

      // Return an array of specified number of amplitudes,
      // where each amplitude represents an average of adjacent amplitudes.
      numberOfAmplitudes++;
      const amplitudesToAverage =
          Math.floor(amplitudes.length / numberOfAmplitudes);
      averagedAmplitudes = new Array();

      // Start at 1 since the first amplitude begins at 0 and is therefore
      // shorter than its neighboring amplitudes.
      for (let i = 1; i < amplitudes.length - amplitudesToAverage;
           i += amplitudesToAverage) {
        let sum = 0;
        for (let j = 0; j < amplitudesToAverage; j++) {
          sum += amplitudes[j + i];
        }
        averagedAmplitudes.push(sum / amplitudesToAverage);
      }

      return averagedAmplitudes;
    }


    function toDecibel_(linearValue) {
      return 20 * Math.log10(linearValue);
    }

    function toIndex_(time, sampleRate) {
      return Math.floor(time * sampleRate);
    }

    function toTime_(index, sampleRate) {
      return index  / sampleRate;
    }

    function getFirstIndexBeforeRemainderIs_(buffer, value) {
      let firstIndex = buffer.length;
      for (let i = 0; i < buffer.length; i++) {
        const diff = Math.abs(buffer[i] - value);
        if (diff > 0) {
          firstIndex = buffer.length;
        } else 
          firstIndex = (i < firstIndex) ? i : firstIndex;
      }
      return firstIndex;
    }

    function getFirstIndexBeforeRemainingSamplesMatch_(buffer, reference) {
      let firstIndex = buffer.length;
      for (let i = 0; i < buffer.length; i++) {
        let diff = Math.abs(buffer[i] - reference[i]);
        if (diff > 0) {
          firstIndex = buffer.length;
        } else
          firstIndex = (i < firstIndex) ? i : firstIndex;
      }
      return firstIndex;
    }
  </script>
  </head>
</html>
