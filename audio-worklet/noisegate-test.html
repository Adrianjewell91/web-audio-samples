<!--
Copyright 2017 Google Inc.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
-->
<!DOCTYPE html>
  <head>
    <script src="test/testharness.js"></script>
    <script src="test/testharnessreport.js"></script>
    <script src="test/audit-util.js"></script>
    <script src="test/audit.js"></script>
    <script src="src/noisegate-script-processor.js"></script>

    <script id="noisegate-test-code">
      // Sample rate is a power of two to avoid interpolation from delay node.
      // It is held artificially low for easy inspection of audio buffers.
      const sampleRate = 4096;
      const testDurationSec = 1;
      const testFrames = testDurationSec * sampleRate;
      const bufferSize = 512;
      const scriptProcessorLatency = bufferSize * 2;
      let audit = Audit.createTaskRunner();
      
      // With a threshold of t and a constant source of some value above t,
      // followed by a sequence of values beneath t, an ideal envelope
      // follower would make the noise gate output equal to the input. But
      // a proper envelope can only be approximated. This test verifies
      // that the envelope delay is mathematically correct given alpha.
      audit.define('envelope-is-mathematically-correct', (task, should) => {
        let context = new OfflineAudioContext(2, testFrames, sampleRate);
        const timeToThreshold = 0.25;

        // The threshold is scaled up by the square root of two since the
        // envelope is tuned to sine waves.
        const linearThreshold = 0.5 * Math.sqrt(2);

        // The noise gate bases muting decisions on a decibel scale.
        const threshold = toDecibel_(linearThreshold);

        // Attack and release are both 0.
        let noisegate = new NoiseGate(context, {bufferSize, threshold});

        // The signal should be all 1's prior to timeToThreshold to simplify
        // the math that relates the closing index to alpha.
        let gain = new GainNode(context, {gain : 1});
        let osc = new ConstantSourceNode(context, {offset: 1});
        osc.connect(gain).connect(noisegate.input);
        noisegate.output.connect(context.destination);

        // The post-threshold gain should make samples less than the threshold.
        // It must be greater than 0; otherwise samples will immediately
        // be 0 after the threshold, and there will be no inspectable delay.
        const beneathThresholdGain = 0.1;
        gain.gain.setValueAtTime(0.1, timeToThreshold);
        
        osc.start();

        context.startRendering().then((buffer) => {
          let channel = buffer.getChannelData(0);

          // With a constant source, the number of steps it takes for the
          // envelope to open and close is a function of alpha relative
          // to the threshold.
          const numOpeningSteps =
              getNumStepsFromZeroUpTo_(linearThreshold, noisegate.alpha_);

          // 1 is added to compensate for rounding. If settings change and one
          // test fails, then remove this addition.
          const numClosingSteps =
              getNumStepsFromOneDownTo_(linearThreshold, noisegate.alpha_) + 1;

          const openIndex = numOpeningSteps + scriptProcessorLatency;
          
          const sourceBeneathThresholdIndex =
              testFrames * timeToThreshold + scriptProcessorLatency;

          let beforeOpenPhase =
              channel.slice(scriptProcessorLatency, openIndex);
          let openPhase = channel.slice(openIndex, sourceBeneathThresholdIndex);
          let closePhase = channel.slice(
              sourceBeneathThresholdIndex + numClosingSteps, channel.length);
          let betweenOpenAndClosePhase =
              channel.slice(sourceBeneathThresholdIndex,
                            sourceBeneathThresholdIndex + numClosingSteps);

          should(beforeOpenPhase, 'The samples before the gate opens')
              .beConstantValueOf(0);
          should(openPhase, 'The open phase').beConstantValueOf(1);
          should(closePhase, 'The closed phase').beConstantValueOf(0);

          // The relativeThreshold is set experimentally, and exists because
          // of the imperfection of floating pointing multiplication. This
          // test may fail for one sample if settings (e.g. alpha) change.
          should(betweenOpenAndClosePhase, 'The samples before the gate closes')
              .beCloseToArray(new Array(betweenOpenAndClosePhase.length)
                                  .fill(beneathThresholdGain),
                              {relativeThreshold : 1e-7});

          // With current settings, the opening delay is 0.00048828125s
          console.log('The opening delay is ' +
                      toTime_(numOpeningSteps, sampleRate));

          // With current settings, the closing delay is 0.003173828125s
          console.log('The closing delay is ' +
                      toTime_(numClosingSteps, sampleRate));

        }).then(() => task.done());
      });

      // Verify that the noise gate computes an envelope for an audio signal
      // that is on the same scale as web audio's gain node. If the gain of a
      // signal is set to be beneath the threshold, then the signal should be
      // muted. The gain of an oscillator is gradually decreased to some
      // threshold T at timeToThreshold, and the output of the noise gate
      // should be 0 after timeToThreshold and unaltered before timeToThreshold
      // within an acceptable margin of error. This test quantifies
      // delay on oscillators, and allows for the bandwidth of the filter to be
      // experimentally determined in a somewhat realistic scenario.
      // The bandwidth can be adjusted to minimize envelope delay while
      // avoiding the gate rapidly changing between open and closed when the
      // sample value is near the threshold.
      audit.define('filter-has-appropriate-bandwidth', (task, should) => {
        let context = new OfflineAudioContext(2, testFrames, sampleRate);
        const timeToThreshold = 0.25;

        // The threshold is between the aboveThresholdGain and
        // belowThresholdGain. If the threshold is close to the
        // belowThresholdGain, then the gate may oscillate between opened and
        // closed, causing the test to fail.
        const linearThreshold = 0.5;
        const threshold = toDecibel_(linearThreshold);
        const aboveThresholdGain = linearThreshold * 1.25;
        const belowThresholdGain = linearThreshold * 0.75;

        // Attack and release are both 0.
        const bandwidth = 70;
        let noisegate =
            new NoiseGate(context, {bufferSize, threshold, bandwidth});
        let gain = new GainNode(context, {gain : 1});
        let merger = new ChannelMergerNode(context, {numberOfInputs : 2});
        
        // The delay node offsets the script processor latency.
        let delay = new DelayNode(
            context, {delayTime : toTime_(scriptProcessorLatency, sampleRate)});
        let osc = new OscillatorNode(context);

        osc.connect(gain).connect(noisegate.input);
        gain.connect(delay);
        noisegate.output.connect(merger, 0, 0);
        delay.connect(merger, 0, 1);
        merger.connect(context.destination);

        gain.gain.setValueAtTime(belowThresholdGain, timeToThreshold);

        // Drop the bass!
        osc.start();

        context.startRendering().then((buffer) => {
          let noiseGateOutput = buffer.getChannelData(0);
          let originalOutput = buffer.getChannelData(1);
         
          const closedIndex =
              toIndex_(timeToThreshold, sampleRate) + scriptProcessorLatency;

          // The output is divided into a latency phase, an unaltered phase, and
          // a closed phase.
          let latencyPhase = noiseGateOutput.slice(0, scriptProcessorLatency);
          let unalteredPhase =
              noiseGateOutput.slice(scriptProcessorLatency, closedIndex);
          let unalteredPhaseReference =
              originalOutput.slice(scriptProcessorLatency, closedIndex);

          // The first k samples run through the noise gate will be somewhat
          // altered. This effect occurs since the envelope does not
          // immediately respond to the level of the signal and it will be
          // beneath the threshold for the first k samples which causes the
          // noise gate to mute the signal.
          const numberOfAlteredSamples =
              getFirstIndexBeforeRemainingSamplesMatch_(
                  unalteredPhase, unalteredPhaseReference);

          // With current settings, delayInSeconds is 0.00048828125s.
          const delayInSeconds = toTime_(numberOfAlteredSamples, sampleRate);
          should(delayInSeconds,
                 'The envelope delay for the very first samples')
              .beCloseTo(0.00048, {threshold: 0.05});

          unalteredPhase = unalteredPhase.slice(numberOfAlteredSamples,
                                                unalteredPhase.length);
          unalteredPhaseReference = unalteredPhaseReference.slice(
              numberOfAlteredSamples, unalteredPhaseReference.length);

          // Based on knowledge of when the signal goes beneath the threshold,
          // it is possible to predict when the signal should be muted. However,
          // this calculation is imperfect since the envelope detection
          // algorithm has a delay.
          let ideallyClosedPhase =
              noiseGateOutput.slice(closedIndex, buffer.length);
          
          // The difference between when the gate is expected to be closed and
          // is closed) is measured at 0.004638671875. If settings change, then
          // closeDelay can be inspected and the assertions can compare to this
          // benchmark instead. The delay occurs due to envelope lag and
          // changes based on alpha. Slight delay may be problematic if the
          // noise gate is intended to immediately mute sound
          // upon hitting a threshold and less problematic if a smooth
          // transition to silence is desired.
          let closeDelay =
              getFirstIndexBeforeRemainderIs_(ideallyClosedPhase, 0);
          should(
              toTime_(closeDelay, sampleRate),
              'The delay between when the envelope is expected to be closed and'
              + ' when it is closed')
              .beCloseTo(0.0046, {threshold: 0.05});
          let closedPhase = ideallyClosedPhase.slice(closeDelay, buffer.length);

          should(latencyPhase, 'The latency phase of noise gate output')
              .beConstantValueOf(0);
          should(unalteredPhase, 'The noise gate values prior to the threshold')
              .beEqualToArray(unalteredPhaseReference,
                              'those values in the unaltered oscillator');
          should(closedPhase, 'The closed phase of the noise gate output')
              .beConstantValueOf(0);
        }).then(() => task.done());
      });

      // When processing two channels, the noise gate should compute only one
      // envelope from the average of those two
      // channels but apply gain computation separately for both channels.
      audit.define('envelope-detects-multiple-channels', (task, should) => {
        const numberOfChannels = 2;

        // The beneathThresholdGain and linearThreshold are set so that
        // (1 * sqrt(2) + beneathThresholdGain * sqrt(2)) / 2 < linearThreshold
        // since the envelope will scale up values by the square root of two and
        // the test is designed so that signals after timeToThreshold are muted
        // in both channels.
        const linearThreshold = 0.7 * Math.sqrt(2);
        const beneathThresholdGain = 0.1;
        const threshold = toDecibel_(linearThreshold);
        const timeToThreshold = 0.5;

        let context =
            new OfflineAudioContext(numberOfChannels, testFrames, sampleRate);
        let constantSource = new ConstantSourceNode(context, {offset: 1});
        let constantSource2 = new ConstantSourceNode(context, {offset: 1});
        let gain = new GainNode(context, {gain: 1});
        let noisegate = new NoiseGate(context,
            {threshold, numberOfChannels, bufferSize});
        let merger = new ChannelMergerNode(context);
        
        // One constant source is connected to a gain node which makes it
        // less than the threshold half way through the buffer.
        constantSource.connect(gain);
        gain.connect(merger, 0, 0);
        constantSource2.connect(merger, 0, 1);
        merger.connect(noisegate.input);
        noisegate.output.connect(context.destination);
        
        gain.gain.setValueAtTime(beneathThresholdGain, timeToThreshold);
        
        constantSource.start();
        constantSource2.start();

        context.startRendering().then((buffer) => {
            let firstChannel = buffer.getChannelData(0);
            let secondChannel = buffer.getChannelData(1);

            const firstSourceIsBeneathGainIndex =
                timeToThreshold * testFrames + scriptProcessorLatency;
            const numOpeningSteps =
                getNumStepsFromZeroUpTo_(linearThreshold, noisegate.alpha_);

            // numClosingSteps is multiplied by two since only one channel
            // is decreasing.
            const numClosingSteps =
                getNumStepsFromOneDownTo_(linearThreshold, noisegate.alpha_) *
                2;

            const openIndex = scriptProcessorLatency + numOpeningSteps;
            const closingIndex =
                numClosingSteps + firstSourceIsBeneathGainIndex;

            let openPhaseFirstChannel =
                firstChannel.slice(openIndex, firstSourceIsBeneathGainIndex);
            let openPhaseSecondChannel =
                secondChannel.slice(openIndex, firstSourceIsBeneathGainIndex);
            let closePhaseFirstChannel =
                firstChannel.slice(closingIndex, firstChannel.length);
            let closePhaseSecondChannel =
                secondChannel.slice(closingIndex, secondChannel.length);

            should(openPhaseFirstChannel, 'The open phase of channel one')
                .beConstantValueOf(1);
            should(openPhaseSecondChannel, 'The open phase of channel two')
                .beConstantValueOf(1);
            should(closePhaseFirstChannel, 'The closed phase')
                .beConstantValueOf(0);
            should(closePhaseSecondChannel, 'The closed phase')
                .beConstantValueOf(0);
            
        }).then(() => task.done());
      });
      
      // Verify that the gain computer opens and closes gate (as witnessed
      // through changes in its weights) according to attack and release
      // settings.
      audit.define('gain-computer-has-attack-and-release', (task, should) => {
        // All envelope values below threshold will receive
        // a zero weight and all values above will receive a weight of one
        // when attack and release are both 0.
        let context = new OfflineAudioContext(1, testFrames, sampleRate);
        
        // envelope[i] = i. Length needs to be an even number.
        const length = 100;
        let envelope = Array.apply(null, {length}).map((data, index) => index);
        const transitionIndex = length / 2;
        const threshold = toDecibel_(length / 2);
        let noisegate = new NoiseGate(context, {threshold});
        let weights = noisegate.computeGain_(envelope);
        let closedWeights = weights.slice(0, transitionIndex);
        let openWeights = weights.slice(transitionIndex, length);
        
        should(closedWeights, 'Weight array before threshold')
            .beConstantValueOf(0);
        should(openWeights, 'Weight array after the threshold')
            .beConstantValueOf(1);
        
        // Verify that the gain computer generates a sequence of increasing or
        // decreasing weights between 0 and 1 at threshold transitions.
        // TransitionSteps must be less than half the envelope length so that
        // both attack and release fit in the evaluation.
        const transitionSteps = 10;
        attack = toTime_(transitionSteps, sampleRate);
        release = attack;
        noisegate = new NoiseGate(context, {attack, release, threshold});
        weights = noisegate.computeGain_(envelope);

        let attackWeights = weights.slice(0, transitionSteps);
        closedWeights = weights.slice(transitionSteps, transitionIndex);
        let releaseWeights =
            weights.slice(transitionIndex, transitionIndex + transitionSteps);
        openWeights =
            weights.slice(transitionIndex + transitionSteps, length);
        let expectedAttackWeights = new Float32Array(transitionSteps);
        let expectedReleaseWeights = new Float32Array(transitionSteps);
        
        // Expected weights should align with noise gates weights. Attack
        // weights increase and release weights decrease.
        for (let j = 0; j < transitionSteps; j++) {
          // The first attack weight is 1 - (1 / transitionSteps).
          expectedAttackWeights[j] = 1 - ((j + 1) / transitionSteps);
          
          // Similarly, the first release weight is 1 / transitionSteps.
          expectedReleaseWeights[j] =  (j + 1) / transitionSteps;
        }

        // Allow for a small error (set experimentally) since the exact change
        // in weight is computed differently here and in noisegate.computeGain.
        const errorThreshold = 1e-6;
        should(attackWeights, 'Attacking weights')
            .beCloseToArray(expectedAttackWeights, {absoluteThreshold: 1e-6});
        should(releaseWeights, 'Releasing weights')
            .beCloseToArray(expectedReleaseWeights, {absoluteThreshold: 1e-6});
        should(closedWeights, 'Weight array before threshold')
            .beConstantValueOf(0);
        should(openWeights, 'Weight array after the threshold')
            .beConstantValueOf(1);
        task.done();
      });

    audit.run();

    // End of test cases. Testing utility functions below!

    function getNumStepsFromZeroUpTo_(threshold, alpha) {
      return Math.floor(Math.log10(1 - (Math.pow(threshold, 2) / 2)) /
                        Math.log10(alpha));
    }

    function getNumStepsFromOneDownTo_(threshold, alpha) {
      return Math.floor(Math.log10(Math.pow(threshold, 2) / 2) /
                            Math.log10(alpha));
    }

    function getFirstIndexBeforeRemainderIs_(buffer, value) {
      let firstIndex = buffer.length;
      for (let i = 0; i < buffer.length; i++) {
        const diff = Math.abs(buffer[i] - value);
        if (diff > 0) {
          firstIndex = buffer.length;
        } else
          firstIndex = (i < firstIndex) ? i : firstIndex;
      }
      return firstIndex;
    }

    function getFirstIndexBeforeRemainingSamplesMatch_(buffer, reference) {
      let firstIndex = buffer.length;
      for (let i = 0; i < buffer.length; i++) {
        let diff = Math.abs(buffer[i] - reference[i]);
        if (diff > 0) {
          firstIndex = buffer.length;
        } else
          firstIndex = (i < firstIndex) ? i : firstIndex;
      }
      return firstIndex;
    }

    function toDecibel_(linearValue) {
      return 20 * Math.log10(linearValue);
    }

    function toIndex_(time, sampleRate) {
      return Math.floor(time * sampleRate);
    }

    function toTime_(index, sampleRate) {
      return index  / sampleRate;
    }
  </script>
  </head>
</html>
