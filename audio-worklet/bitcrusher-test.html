<!--
Copyright 2017 Google Inc.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
-->
<!DOCTYPE html>
  <head>
    <script src="src/bitcrusher-script-processor.js"></script> 
    <script>
    	testSampleReduction();
    	testBitcrusherInContext();
    	testMultipleChannels();
    	testIllegalInput();

    	/**
    	 * Populate array with 0:99 and verify the bitcrusher holds an array
    	 * where the number of consecutive equal numbers is controlled by the 
    	 * variable factor.
    	 */
    	function testSampleReduction() {
    	  let context = new OfflineAudioContext(2, 44100, 44100);

    	  for (let reduction = 1; reduction < 10; reduction++) {
    	    const bufferSize = 5;
    	    let referenceBuffer = new Float32Array(bufferSize);
    	    let outputBuffer = new Float32Array(bufferSize);
    	    let bitcrusher =
    	        new Bitcrusher(context, {bitDepth: 24, reduction: reduction});

    	    for (let i = 0; i < bufferSize; i++) {
    	      referenceBuffer[i] = i;
    	    }

    	    bitcrusher.processBuffer_(referenceBuffer, outputBuffer);

    	    // Verify computed values match expected values.
    	    outputBuffer.map((data, index) => {
    	      let expected = Math.floor(index / reduction) * reduction;
    	      console.assert(
    	          data === expected, 
    	          'computed ' + data + ' but expected ' + expected);
    	    });
    	  }
    	}

    	/**
    	 * Create one oscillator, and connect it to a bitcrusher with variables 
    	 * set to avoid any effect and a delay node which compensates for the 
    	 * script processor latency. Then verify that the samples are nearly
    	 * identical.
    	 */
    	function testBitcrusherInContext() { 
    	  let context = new OfflineAudioContext(2, 44100, 44100);
    	  const reduction = 1;
    	  const bitDepth = 24;
    	  const bufferLength = 512;
    	  let oscillator = new OscillatorNode(context);
    	  oscillator.start();

    	  let merger = new ChannelMergerNode(context, {numberOfInputs: 2});
    	  let bitcrusher = new Bitcrusher(context, {
    	    buffersize: bufferLength,
    	    channels: 1,
    	    bitDepth: bitDepth,
    	    reduction: reduction
    	  });

    	  // Accomodate for script processor latency by delaying the oscillator.
    	  let delay = context.createDelay();
    	  delay.delayTime.value = bufferLength / context.sampleRate;

    	  oscillator.connect(bitcrusher.input);
    	  bitcrusher.output.connect(merger, 0, 0);
    	  oscillator.connect(delay).connect(merger, 0, 1);
    	  merger.connect(context.destination);

    	  // When audio buffer is ready, verify bitcrushed samples are unaltered.
    	  context.startRendering()
    	      .then((buffer) => {
    	        let bitcrusherOutput = buffer.getChannelData(0);
    	        let originalOutput = buffer.getChannelData(1);

    	        // Allow for fractional error beyond audible perception. This 
    	        // error occurs because any sample passing through bitcrusher will 
    	        // undergo manipulation in Math.round() and will therefore be 
    	        // represented by a new floating point number that differs     	       // slightly from the original.
    	        // In tested samples and at a sample rate of 44,1k, the 
    	        // maximum observed error is 6.183981895446777e-7.
    	        
    	        const permittedSampleError = 6.1840e-7;
    	        let maxError = 0;
    	        for (let i = 0; i < bitcrusherOutput.length; i++) {
    	          let diff = Math.abs(bitcrusherOutput[i] - originalOutput);
    	          if (diff > maxError) maxError = diff;  
    	        }
    	        console.assert(
    	            maxError < permittedSampleError,
    	            'The maximum error between bitcrusher and original output, ' +
    	                maxError + ', exceeds the maximum permitted error, ' +
    	                permittedSampleError);

    	        // Verify samples from unadultered oscillator match samples from
    	        // bitcrushed oscillator with non-information reducing parameters.
    	        for (let i = 0; i < originalOutput.length; i++) {
    	          let crushedSample = bitcrusherOutput[i];
    	          let originalSample = originalOutput[i];
    	          const diff = Math.abs(originalSample - crushedSample);
    	          
    	          if (i < bufferLength) {
    	            console.assert(
    	                bitcrusherOutput[i] == 0,
    	                'Bitcrusher sample at ' + i + 'expected to be 0 but it'
    	                + ' was ' + bitcrusherOutput[i]);
    	          }
    	          console.assert(
    	              diff < permittedSampleError,
    	              'Bitcrushed sample at ' + i + ' is ' + crushedSample + 
    	              ' but ' + originalSample + ' for oscillator');
    	        }
    	      });
    	}

    	/**
    	 * Verify that bitcrusher handles illegal input correctly.
    	 */
    	function testIllegalInput() {
    	  try {
    	    let bitcrusher = new Bitcrusher(0);
    	    console.error('Bitcrusher did not throw illegal context error.');
    	  }
    	  catch (error) {}
    	}

    	/**
    	 * Verify that bitcrusher applies sample reduction on multiple channels of 
    	 * input, and that sample reduction works across multiple buffers (which 
    	 * requires bitcrusher memory.)
    	 */
    	function testMultipleChannels() {
    	  let channels = 2;
    	  let context = new OfflineAudioContext(channels, 44100, 44100);
    	  // Reduction should not be a factor of buffersize for full coverage.
    	  const reduction = 7; 
    	  const bitDepth = 24;
    	  const bufferSize = 512;
    	  let oscillator = new OscillatorNode(context);
    	  let splitter = new ChannelSplitterNode(context);

    	  let bitcrusher = new Bitcrusher(context, {
    	    bufferSize: bufferSize,
    	    channels: channels,
    	    bitDepth: bitDepth,
    	    reduction: reduction
    	  })

    	  oscillator.connect(splitter).connect(bitcrusher.input);
    	  bitcrusher.output.connect(context.destination); 
    	  oscillator.start();
    	  
    	  // When audio buffer is ready, verify bitcrushed samples are unaltered.
    	  context.startRendering().then((buffer) => {      
    	      let last = buffer.getChannelData(0)[0];
    	      for (let i = 1; i < buffer.getChannelData(0).length; i++) {
    	        for (let c = 0; c < channels; c++) {
    	          console.assert(
    	              buffer.getChannelData(c)[i] === last, 
    	              'At iteration ' + i + ', the value at channel ' + c + ', ' +
    	                  buffer.getChannelData(c)[i] + ' did not match ' +
    	                  ' expectation, ' + last);
    	          if (i % reduction === 0) last = buffer.getChannelData(c)[i];
    	        }
    	     } 
    	  });  
    	}
    </script> 
  </head>
</html>
